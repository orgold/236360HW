%{
	#include <iostream>
	#include <stdlib.h>
	#include "hw4_table_utils.h"
	using namespace std;

	extern int yylex();
	int yyerror(char * message);
	SymbolTable symbolTable;

%}

%left OR;
%left AND;
%left RELOP2;
%left RELOP1;
%left BINOP2;
%left BINOP1;
%right NOT;


%token SC;
%token COLON;
%token ASSIGN;
%token RETURN;
%token BREAK;
%token LBRACE;
%token RBRACE;
%token IF;
%token ELSE;
%token WHILE;
%token SWITCH;
%token CASE;
%nonassoc LPAREN;
%nonassoc RPAREN;
%nonassoc COMMA;
%nonassoc VOID;
%nonassoc INT;
%nonassoc BYTE;
%nonassoc BOOL;
%nonassoc TRUE FALSE;
%nonassoc ID;

%nonassoc STRING;
%nonassoc NUM;
%nonassoc B;


%%


program : funcs 			{cout<<"program -> funcs"<<endl;}

funcs 
	: 						{cout<<"funcs -> eps"<<endl;}
	| fundecl funcs 		{cout<<"funcs -> fundecl funcs"<<endl;}

statements
	: statement				{cout<<"statements -> statement"<<endl;}
	| statements statement 	{cout<<"statements -> statements statement"<<endl;}

statement
	: openstatement			{cout<<"statement -> openstatement"<<endl;}
	| closedstatement		{cout<<"statement -> closedstatement"<<endl;}

openstatement
	: IF LPAREN exp RPAREN statement							{cout<<"openstatement -> IF LPAREN exp RPAREN statement"<<endl;}
	| IF LPAREN exp RPAREN closedstatement ELSE openstatement	{cout<<"openstatement -> IF LPAREN exp RPAREN closedstatement ELSE openstatement"<<endl;}
	| WHILE LPAREN exp RPAREN openstatement						{cout<<"openstatement -> WHILE LPAREN exp RPAREN openstatement"<<endl;}

closedstatement
	: simplestatement 											{cout<<"closedstatement -> simplestatement"<<endl;}
	| IF LPAREN exp RPAREN closedstatement ELSE closedstatement	{cout<<"closedstatement -> IF LPAREN exp RPAREN closedstatement ELSE closedstatement"<<endl;}
	| WHILE LPAREN exp RPAREN closedstatement					{cout<<"closedstatement -> WHILE LPAREN exp RPAREN closedstatement"<<endl;}
	| SWITCH LPAREN exp RPAREN LBRACE caselist RBRACE SC		{cout<<"closedstatement -> SWITCH LPAREN exp RPAREN LBRACE caselist RBRACE SC"<<endl;}

caselist
	: casestat									{cout<<"caselist -> casestat"<<endl;}
	| casestat caselist							{cout<<"caselist -> casestat caselist"<<endl;}

casestat
	: CASE NUM COLON statement BREAK SC 		{cout<<"casestat -> CASE NUM COLON statement BREAK SC"<<endl;}
	| CASE NUM B COLON statement BREAK SC 		{cout<<"casestat -> CASE NUM B COLON statement BREAK SC"<<endl;}

simplestatement 
	: type ID SC				{
								try{
								insertVar($2.idName,$1.type);
								}
								catch(errorDefException e)
								{
									errorDef($2.lineno,e.id.c_str());
									exit(1);
								}
								free($2.idName);
								$$.lineno = $2.lineno;
								cout<<"simplestatement -> type ID SC"<<endl;}
	| type ID ASSIGN exp SC 	{
								try{
								insertVar($2.idName,$1.type);
								}
								catch(errorDefException e)
								{
									errorDef($2.lineno,e.id.c_str());
									exit(1);
								}
								if($1.type!= $4.type && !($1.type==INT_T&&$4.type==BYTE_T)) 
								{
									errorMismatch($2.lineno);
								exit(1);
								}
								free($2.idName);
								$$.lineno = $2.lineno;
									cout<<"simplestatement -> type ID ASSIGN exp SC"<<endl;}
	| ID ASSIGN exp SC 			{
								try{
								TYPE tempType=symbolTable.getType($1.idName);
								if(tempType!= $3.type && !(tempType==INT_T&&$3.type==BYTE_T)) 
								{
									errorMismatch($2.lineno);
								exit(1);
								}
								}
								catch(errorUndefException& e)
								{
										errorUndef($1.lineno,$1.idName);
										exit(1);
								}
								
		
								cout<<"simplestatement -> ID ASSIGN exp SC"<<endl;}
	| call SC 					{cout<<"simplestatement -> call SC"<<endl;}
	| RETURN SC 				{cout<<"simplestatement -> RETURN SC"<<endl;}
	| RETURN exp SC				{cout<<"simplestatement -> RETURN exp SC"<<endl;}
	| BREAK SC 					{	
									$$.hasBreak=true;
									cout<<"simplestatement -> BREAK SC"<<endl;
								}
	| LBRACE statements RBRACE 	{cout<<"simplestatement -> { statements }"<<endl;}

	

fundecl 
	: fundecl_helper RPAREN LBRACE statements RBRACE		{cout<<"fundecl -> rettype ID LPAREN formals RPAREN"<<endl;}

fundecl_helper 
	: rettype ID LPAREN formals   	{
										try {
											symbolTable.coverInsertFunction($2.idName,$4.typeList,$4.typeListSize,$1.type,$4.idList);
										}
										catch(errorDefException& e)
										{
											errorDef($2.lineno,$2.idName);
											exit(1);
										}
										$$.type=$1.type;
										free($2.idName);
										free($4.typeList);
										free($4.idList);
									}
exp 
	: exp BINOP1 exp 			{
									if( $1.type != INT_T  &&
										$1.type != BYTE_T ||
										$3.type != INT_T  &&
										$3.type != BYTE_T )
									{
										errorMismatch($1.lineno);
										exit(1);
									}
									if( $1.type == INT_T ||
										$3.type == INT_T )
									{
										$$.type == INT_T;
									} else {
										$$.type == BYTE_T;
									}
									$$.lineno = $1.lineno;
									cout<<"exp -> exp BINOP1 exp"<<endl;
								}
	| exp BINOP2 exp			{
									if( $1.type != INT_T  &&
										$1.type != BYTE_T ||
										$3.type != INT_T  &&
										$3.type != BYTE_T )
									{
										errorMismatch($1.lineno);
										exit(1);
									}
									if( $1.type == INT_T ||
										$3.type == INT_T )
									{
										$$.type == INT_T;
									} else {
										$$.type == BYTE_T;
									}
									$$.lineno = $1.lineno;
									cout<<"exp -> exp BINOP2 exp"<<endl;
								}
	| NUM 						{
									$$.type = INT_T;
									$$.lineno = $1.lineno;
									free($1.value);
									cout<<"exp -> num"<<endl;
								}
	| LPAREN exp RPAREN 		{
									$$.type = $2.type;
									cout<<"exp -> LPAREN exp RPAREN"<<endl;
								}
	| NOT exp					{
									if($2.type != BOOL_T){
										errorMismatch($1.lineno);
										exit(1);
									}
									$$.type = BOOL_T;
									$$.lineno = $1.lineno;
									cout<<"exp -> NOT exp"<<endl;
								}
	| exp AND exp 				{
									if( $1.type != BOOL_T ||
										$3.type != BOOL_T)
									{
										errorMismatch($1.lineno);
										exit(1);
									}
									$$.type = BOOL_T;
									$$.lineno = $1.lineno;
									cout<<"exp -> exp AND exp"<<endl;
								}
	| exp OR exp 				{
									if( $1.type != BOOL_T ||
										$3.type != BOOL_T)
									{
										errorMismatch($1.lineno);
										exit(1);
									}
									$$.type = BOOL_T;
									$$.lineno = $1.lineno;
									cout<<"exp -> exp OR exp"<<endl;
								}
	| TRUE						{
									$$.type=BOOL_T;
									$$.lineno = $1.lineno;
									cout<<"exp -> TRUE"<<endl;
								}
	| FALSE 					{
									$$.type=BOOL_T;
									$$.lineno = $1.lineno;
									cout<<"exp -> FALSE"<<endl;
								}
	| exp RELOP1 exp 			{
									if( $1.type != INT_T  &&
										$1.type != BYTE_T ||
										$3.type != INT_T  &&
										$3.type != BYTE_T )
									{
										errorMismatch($1.lineno);
										exit(1);
									}
									$$.type = BOOL_T;
									$$.lineno = $1.lineno;
									cout<<"exp -> exp RELOP1 exp"<<endl;
								}
	| exp RELOP2 exp 			{
									if( $1.type != INT_T  &&
										$1.type != BYTE_T ||
										$3.type != INT_T  &&
										$3.type != BYTE_T )
									{
										errorMismatch($1.lineno);
										exit(1);
									}
									$$.type = BOOL_T;
									$$.lineno = $1.lineno;
									cout<<"exp -> exp RELOP2 exp"<<endl;
								}
	| STRING 					{
									$$.type = STRING_T;
									$$.lineno = $1.lineno;
									cout<<"exp -> STRING"<<endl;
								}
	| ID 						{
								try{
								$$.lineno = $1.lineno;
								$$.type=symbolTable.getType($1.idName);
								}
								catch (errorUndefException& e)
								{
									errorUndef($$.lineno,e.id.c_str()); 
									exit(1);
								}
								free($1.idName);
								cout<<"exp -> ID"<<endl;
								}
								
	| NUM B 					{
									if (atoi($1.value)>255){
										errorByteTooLarge($1.lineno,$1.value);//TODO change this
										exit(1);
									}
									$$.type = BYTE_T;
									$$.lineno = $1.lineno;
									free($1.value);
									cout<<"exp -> NUM B"<<endl;
								}
	| call 						{
									$$.type = $1.type;
									cout<<"exp -> call"<<endl;
								}

call 
	: ID LPAREN RPAREN 			{
								try {
								$$.type=symbolTable.checkFuncTypeAndArgs($1.idName,nullptr,0);
								}
								catch (errorUndefFuncException& e){
									errorUndefFunc($1.lineno,e.id);
									exit(1);
								}
								catch (errorPrototypeMismatchException& e)
								{
									errorPrototypeMismatch($1.lineno,e.id,e.argTypes);
									exit(1);
								}
								free($1.idName);
								
								$$.lineno = $1.lineno;
									cout<<"exp -> ID LPAREN RPAREN"<<endl;}
	| ID LPAREN explist RPAREN 	{
								try {
								$$.type=symbolTable.checkFuncTypeAndArgs($1.idName,$3.typeList,$3.typeListSize);
								}
								catch (errorUndefFuncException& e){
									errorUndefFunc($1.lineno,e.id);
									exit(1);
								}
								catch (errorPrototypeMismatchException& e)
								{
									errorPrototypeMismatch($1.lineno,e.id,e.argTypes);
									exit(1);
								}
								$$.lineno = $1.lineno;
								free($1.idName);
								free($3.typeList);
								cout<<"exp -> ID LPAREN explist RPAREN"<<endl;}

explist 
	: exp 						{
								$$.typeList=(TYPE*)malloc(sizeof(TYPE));
								$$.typeListSize=1;
								$$.typeList[0]=$1.type;
								cout<<"explist -> exp"<<endl;}
	| exp COMMA explist  		{
								$$.typeList =(TYPE*) realloc($3.typeList,sizeof(TYPE)*($3.typeListSize+1));
								$$.typeListSize=$3.typeListSize+1;
								$$.typeList[$3.typeListSize]=$1.type;
								cout<<"explist -> exp COMMA explist"<<endl;}

type 
	: INT 						{
								$$.type=INT_T;
								cout<<"type -> INT"<<endl;}
	| BYTE 						{
								$$.type=BYTE_T;
								cout<<"type -> BYTE"<<endl;}
	| BOOL 						{
								$$.type=BOOL_T;
								cout<<"type -> BOOL"<<endl;}

formals 
	: 							{cout<<"formals -> eps"<<endl;}
	| formalslist 				{cout<<"formals -> formalslist"<<endl;}

formalslist	
	: formaldecl 					{cout<<"formalslist -> formaldecl"<<endl;}
	| formaldecl COMMA formalslist 	{cout<<"formalslist -> formaldecl COMMA formalslist"<<endl;}

formaldecl : type ID 			{cout<<"formaldecl -> type ID "<<endl;}

rettype 
	: type 						{
								$$.type=$1.type;
								cout<<"rettype -> type  "<<endl;}
	| VOID 						{
								$$.type=VOID_T;
								cout<<"rettype -> VOID"<<endl;}
%%

int main()
{
	yyparse();
}

int yyerror(char * message)
{
	cout<<"Parse error: "<<message<<endl;
	exit(0);
}