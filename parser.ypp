%{
	#include <iostream>
	#include <stdlib.h>
	#include "hw4_table_utils.h"
	using namespace std;

	extern int yylex();
	void yyerror(char * message);
	SymbolTable symbolTable;
	TYPE globalFunctionRetType;
	bool globalIsDeclSensitive = 0;
	extern int yylineno;
%}

%locations

%left OR;
%left AND;
%left RELOP2;
%left RELOP1;
%left BINOP2;
%left BINOP1;
%right NOT;

%token END_OF_FILE;
%token SC;
%token COLON;
%token ASSIGN;
%token RETURN;
%token BREAK;
%token LBRACE;
%token RBRACE;
%token IF;
%token ELSE;
%token WHILE;
%token SWITCH;
%token CASE;
%nonassoc LPAREN;
%nonassoc RPAREN;
%nonassoc COMMA;
%nonassoc VOID;
%nonassoc INT;
%nonassoc BYTE;
%nonassoc BOOL;
%nonassoc TRUE FALSE;
%nonassoc ID;

%nonassoc STRING;
%nonassoc NUM;
%nonassoc B;

%%


program 
	: funcs 		{
						try{
							TYPE typeTemp = symbolTable.checkFuncTypeAndArgs("main", NULL,0);
							if (typeTemp != VOID_T){
								errorMainMissing();
								exit(1);
							}
						}
						catch (errorUndefFuncException& e){
							errorMainMissing();
							exit(1);
						}
						catch (errorPrototypeMismatchException& e){
							errorMainMissing();
							exit(1);
						}
						symbolTable.removeGlobalScope();
						//cout<<"program -> funcs"<<endl;
					}


funcs 
	: fundecl funcs			{}
	| 						{/*cout<< "took the empty" << endl;*/}


statements
	: statement				{
								$$.hasBreak = $1.hasBreak;
								$$.lineno = $1.lineno;
								//cout<<"statements -> statement"<<endl;
							}
	| statements statement 	{
								if($1.hasBreak){
										$$.hasBreak = 1;
										$$.lineno = $1.lineno;
									}
									else {
										$$.hasBreak = $2.hasBreak;
										$$.lineno = $2.lineno;
									}
								//cout<<"statements -> statements statement"<<endl;
							}

statement
	: openstatement			{
								$$.hasBreak = $1.hasBreak;
								$$.lineno = $1.lineno;
								//cout<<"statement -> openstatement"<<endl;
							}
	| closedstatement		{
								$$.hasBreak = $1.hasBreak;
								$$.lineno = $1.lineno;
								//cout<<"statement -> closedstatement"<<endl;
							}

MarkOn:  {globalIsDeclSensitive = true;}
MarkOff: {globalIsDeclSensitive = false;}

IfStart: IF LPAREN exp 			{if($3.type != BOOL_T){errorMismatch($1.lineno);exit(1);}}

WhileStart : WHILE LPAREN exp {if($3.type != BOOL_T){errorMismatch($1.lineno);exit(1);}}

openstatement
	: IfStart RPAREN MarkOn statement MarkOff			{
																$$.hasBreak = $4.hasBreak;
																$$.lineno = $4.lineno;
																//cout<<"openstatement -> IF LPAREN exp RPAREN statement"<<endl;
															}

	| IfStart RPAREN MarkOn closedstatement MarkOff ELSE MarkOn openstatement MarkOff	
		{
			if($4.hasBreak)
				{
					$$.hasBreak=1;
					$$.lineno = $4.lineno;
				}
				else 
				{
					$$.hasBreak=$7.hasBreak;
					$$.lineno = $7.lineno;
				}
			//cout<<"openstatement -> IF LPAREN exp RPAREN closedstatement ELSE openstatement"<<endl;
		}
	| WhileStart RPAREN MarkOn openstatement MarkOff		{
																	$$.hasBreak = 0;
																	//cout<<"openstatement -> WHILE LPAREN exp RPAREN openstatement"<<endl;
																}

closedstatement
	: simplestatement 											{
																	$$.hasBreak = $1.hasBreak;
																	$$.lineno = $1.lineno;
																	//cout<<"closedstatement -> simplestatement"<<endl;
																}
	| IfStart RPAREN MarkOn closedstatement MarkOff ELSE MarkOn closedstatement MarkOff
		{
			if($4.hasBreak)
			{
				$$.hasBreak=1;
				$$.lineno = $4.lineno;
			}
			else 
			{
				$$.hasBreak=$7.hasBreak;
				$$.lineno = $7.lineno;
			}
			//cout<<"closedstatement -> IF LPAREN exp RPAREN closedstatement ELSE closedstatement"<<endl;
		}
	| WhileStart RPAREN MarkOn closedstatement MarkOff	{
																	$$.hasBreak = 0;
																	//cout<<"closedstatement -> WHILE LPAREN exp RPAREN closedstatement"<<endl;
																}
	| SWITCH LPAREN exp {if($3.type != BYTE_T && $3.type != INT_T){errorMismatch($1.lineno);exit(1);}} RPAREN LBRACE caselist RBRACE SC		{
																	$$.hasBreak = $7.hasBreak;
																	$$.lineno = $7.lineno;
																	//cout<<"closedstatement -> SWITCH LPAREN exp RPAREN LBRACE caselist RBRACE SC"<<endl;
																}

caselist
	: casestat					{
									if($1.hasBreak){
										$$.hasBreak = 1;
										$$.lineno = $1.lineno;
									}
									//cout<<"caselist -> casestat"<<endl;
								}
	| casestat caselist			{
									if($1.hasBreak){
										$$.hasBreak = 1;
										$$.lineno = $1.lineno;
									}
									else {
										$$.hasBreak = $2.hasBreak;
										$$.lineno = $2.lineno;
									}
									//cout<<"caselist -> casestat caselist"<<endl;
								}

casestat
	: CASE NUM COLON   MarkOn statement MarkOff BREAK SC 		{
													$$.hasBreak = $5.hasBreak;
													$$.lineno = $5.lineno;
													//cout<<"casestat -> CASE NUM COLON statement BREAK SC"<<endl;
												}
	| CASE NUM B COLON MarkOn statement MarkOff BREAK SC 		{
													$$.hasBreak = $6.hasBreak;
													$$.lineno = $6.lineno;
													//cout<<"casestat -> CASE NUM B COLON statement BREAK SC"<<endl;
												}

simplestatement 
	: type ID SC				{
									if(globalIsDeclSensitive)
										symbolTable.insertScope();
									try{
										symbolTable.insertVar($2.idName,$1.type);
									}
									catch(errorDefException e)
									{
										errorDef($2.lineno,e.id.c_str());
										exit(1);
									}
									if(globalIsDeclSensitive)
										symbolTable.removeScope();
									free($2.idName);
									//$$.lineno = $2.lineno;
									$$.hasBreak =0;
									//cout<<"simplestatement -> type ID SC"<<endl;
								}
	| type ID ASSIGN exp SC 	{
									if(globalIsDeclSensitive)
										symbolTable.insertScope();
									try{
										symbolTable.insertVar($2.idName,$1.type);
									}
									catch(errorDefException e)
									{
										errorDef($2.lineno,e.id.c_str());
										exit(1);
									}
									if( $1.type!= $4.type &&
									  !($1.type==INT_T&&$4.type==BYTE_T)) 
									{
										errorMismatch($2.lineno);
										exit(1);
									}
									if(globalIsDeclSensitive)
										symbolTable.removeScope();
									free($2.idName);
									$$.lineno = $2.lineno;
									$$.hasBreak =0;
									//cout<<"simplestatement -> type ID ASSIGN exp SC"<<endl;
								}
	| ID ASSIGN exp SC 			{
									try{
										TYPE tempType=symbolTable.getType($1.idName);
										if(tempType!= $3.type && !(tempType==INT_T&&$3.type==BYTE_T)) 
										{
											errorMismatch($2.lineno);
											exit(1);
										}
									}
									catch(errorUndefException& e)
									{
											errorUndef($1.lineno,$1.idName);
											exit(1);
									}
									$$.hasBreak =0;
									//cout<<"simplestatement -> ID ASSIGN exp SC"<<endl;
								}
	| call SC 					{
									$$.hasBreak =0;
									//cout<<"simplestatement -> call SC"<<endl;
								}
	| RETURN SC 				{
									if(globalFunctionRetType != VOID_T) 
									{
										errorMismatch($1.lineno);
										exit(1);
									}
									$$.hasBreak =0;
									//cout<<"simplestatement -> RETURN SC"<<endl;
								}
	| RETURN exp SC				{
									if( globalFunctionRetType != $2.type && 
									    !(globalFunctionRetType ==INT_T &&$2.type == BYTE_T )
										|| globalFunctionRetType == VOID_T)
									{
										errorMismatch($1.lineno);
										exit(1);
									}
									
									$$.hasBreak =0;
									//cout<<"simplestatement -> RETURN exp SC"<<endl;
								}
	| BREAK SC 					{	
									$$.hasBreak = true;
									$$.lineno = $1.lineno;
									//cout<<"simplestatement -> BREAK SC"<<endl;
								}
	| LBRACE {symbolTable.insertScope(); globalIsDeclSensitive=false;} statements RBRACE 	
		{						
			$$.hasBreak = $2.hasBreak;
			$$.lineno = $2.lineno;
			symbolTable.removeScope();
			//cout<<"simplestatement -> { statements }"<<endl;
		}

	

fundecl 
	: fundecl_helper RPAREN LBRACE statements RBRACE 		{
																if($4.hasBreak)
																{
																	errorUnexpectedBreak($4.lineno);
																	exit(1);
																}
																symbolTable.removeScope();
																//cout<<"fundecl -> rettype ID LPAREN formals RPAREN"<<endl;
															}

fundecl_helper 
	: rettype ID LPAREN formals   	{
										try {
											symbolTable.coverInsertFunction($2.idName,$4.typeList,$4.typeListSize,$1.type,$4.idList);
										}
										catch(errorDefException& e)
										{
											errorDef($2.lineno,$2.idName);
											exit(1);
										}
										globalFunctionRetType = $1.type;
										$$.type=$1.type;
										free($2.idName);
										free($4.typeList);
										for(int i = 0; i < $4.typeListSize ; i++)
											free($4.idList[i]);
										free($4.idList);
									}
exp 
	: exp BINOP1 exp 			{
									if( $1.type != INT_T  &&
										$1.type != BYTE_T ||
										$3.type != INT_T  &&
										$3.type != BYTE_T )
									{
										errorMismatch($1.lineno);
										exit(1);
									}
									if( $1.type == INT_T ||
										$3.type == INT_T )
									{
										$$.type = INT_T;
									} else {
										$$.type = BYTE_T;
									}
									$$.lineno = $1.lineno;
									//cout<<"exp -> exp BINOP1 exp"<<endl;
								}
	| exp BINOP2 exp			{
									if( $1.type != INT_T  &&
										$1.type != BYTE_T ||
										$3.type != INT_T  &&
										$3.type != BYTE_T )
									{
										errorMismatch($1.lineno);
										exit(1);
									}
									if( $1.type == INT_T ||
										$3.type == INT_T )
									{
										$$.type = INT_T;
									} else {
										$$.type = BYTE_T;
									}
									$$.lineno = $1.lineno;
									//cout<<"exp -> exp BINOP2 exp: $$ type type is: " << toCString($$.type)<<endl;
								}
	| NUM 						{
									$$.type = INT_T;
									$$.lineno = $1.lineno;
									free($1.value);
									//cout<<"exp -> num"<<endl;
								}
	| LPAREN exp RPAREN 		{
									$$.type = $2.type;
									//cout<<"exp -> LPAREN exp RPAREN"<<endl;
								}
	| NOT exp					{
									if($2.type != BOOL_T){
										errorMismatch($1.lineno);
										exit(1);
									}
									$$.type = BOOL_T;
									$$.lineno = $1.lineno;
									//cout<<"exp -> NOT exp"<<endl;
								}
	| exp AND exp 				{
									if( $1.type != BOOL_T ||
										$3.type != BOOL_T)
									{
										errorMismatch($1.lineno);
										exit(1);
									}
									$$.type = BOOL_T;
									$$.lineno = $1.lineno;
									//cout<<"exp -> exp AND exp"<<endl;
								}
	| exp OR exp 				{
									if( $1.type != BOOL_T ||
										$3.type != BOOL_T)
									{
										errorMismatch($1.lineno);
										exit(1);
									}
									$$.type = BOOL_T;
									$$.lineno = $1.lineno;
									//cout<<"exp -> exp OR exp"<<endl;
								}
	| TRUE						{
									$$.type=BOOL_T;
									$$.lineno = $1.lineno;
									//cout<<"exp -> TRUE"<<endl;
								}
	| FALSE 					{
									$$.type=BOOL_T;
									$$.lineno = $1.lineno;
									//cout<<"exp -> FALSE"<<endl;
								}
	| exp RELOP1 exp 			{
									if( $1.type != INT_T  &&
										$1.type != BYTE_T ||
										$3.type != INT_T  &&
										$3.type != BYTE_T )
									{
										errorMismatch($1.lineno);
										exit(1);
									}
									$$.type = BOOL_T;
									$$.lineno = $1.lineno;
									//cout<<"exp -> exp RELOP1 exp"<<endl;
								}
	| exp RELOP2 exp 			{
									if( $1.type != INT_T  &&
										$1.type != BYTE_T ||
										$3.type != INT_T  &&
										$3.type != BYTE_T )
									{
										errorMismatch($1.lineno);
										exit(1);
									}
									$$.type = BOOL_T;
									$$.lineno = $1.lineno;
									//cout<<"exp -> exp RELOP2 exp"<<endl;
								}
	| STRING 					{
									$$.type = STRING_T;
									$$.lineno = $1.lineno;
									//cout<<"exp -> STRING"<<endl;
								}
	| ID 						{
								try{
									$$.lineno = $1.lineno;
									$$.type=symbolTable.getType($1.idName);
								}
								catch (errorUndefException& e)
								{
									errorUndef($$.lineno,e.id.c_str()); 
									exit(1);
								}
								//cout<<"exp -> ID: " << $1.idName << " of type: " << toCString($$.type) <<endl;
								free($1.idName);
								}
								
	| NUM B 					{
									if (atoi($1.value)>255){
										errorByteTooLarge($1.lineno,$1.value);//TODO change this
										exit(1);
									}
									$$.type = BYTE_T;
									$$.lineno = $1.lineno;
									free($1.value);
									//cout<<"exp -> NUM B"<<endl;
								}
	| call 						{
									$$.type = $1.type;
									//cout<<"exp -> call"<<endl;
								}

call 
	: ID LPAREN RPAREN 			{
								try {
								$$.type=symbolTable.checkFuncTypeAndArgs($1.idName,NULL,0);
								}
								catch (errorUndefFuncException& e){
									errorUndefFunc($1.lineno,e.id.c_str());
									exit(1);
								}
								catch (errorPrototypeMismatchException& e)
								{
									errorPrototypeMismatch($1.lineno,e.id.c_str(),e.argTypes);
									exit(1);
								}
								free($1.idName);
								
								$$.lineno = $1.lineno;
									//cout<<"exp -> ID LPAREN RPAREN"<<endl;
									}
	| ID LPAREN explist RPAREN 	{
								try {
								$$.type=symbolTable.checkFuncTypeAndArgs($1.idName,$3.typeList,$3.typeListSize);
								}
								catch (errorUndefFuncException& e){
									errorUndefFunc($1.lineno,e.id.c_str());
									exit(1);
								}
								catch (errorPrototypeMismatchException& e)
								{
									errorPrototypeMismatch($1.lineno,e.id.c_str(),e.argTypes);
									exit(1);
								}
								$$.lineno = $1.lineno;
								free($1.idName);
								free($3.typeList);
								//cout<<"exp -> ID LPAREN explist RPAREN"<<endl;
								}

explist 
	: exp 						{
								$$.typeList=(TYPE*)malloc(sizeof(TYPE));
								$$.typeListSize=1;
								$$.typeList[0]=$1.type;
								//cout<<"explist -> exp"<<endl;
								}
	| exp COMMA explist  		{
								$$.typeList =(TYPE*) realloc($3.typeList,sizeof(TYPE)*($3.typeListSize+1));
								$$.typeListSize=$3.typeListSize+1;
								$$.typeList[$3.typeListSize]=$1.type;
								//cout<<"explist -> exp COMMA explist"<<endl;
								}

type 
	: INT 						{
								$$.type=INT_T;
								//cout<<"type -> INT"<<endl;
								}
	| BYTE 						{
								$$.type=BYTE_T;
								//cout<<"type -> BYTE"<<endl;
								}
	| BOOL 						{
								$$.type=BOOL_T;
								//cout<<"type -> BOOL"<<endl;
								}

formals 
	: 							{
									$$.typeListSize = 0;
									//cout<<"formals -> eps"<<endl;
								}
	| formalslist 				{
									$$.typeList = $1.typeList;
									$$.typeListSize = $1.typeListSize;
									$$.idList = $1.idList;
									//cout<<"formals -> formalslist"<<endl;
								}

formalslist	
	: formaldecl 					{
										$$.typeList = (TYPE*) malloc(sizeof(TYPE));
										$$.typeListSize = 1;
										$$.typeList[0] = $1.type;
										$$.idList = (char**) malloc(sizeof(char*));
										$$.idList[0] = $1.idName;
										//cout<<"formalslist -> formaldecl"<<endl;
									}
	| formaldecl COMMA formalslist 	{
										$$.typeList = (TYPE*) realloc($3.typeList, sizeof(TYPE)*($3.typeListSize + 1));
										$$.typeListSize = $3.typeListSize + 1;
										$$.typeList[$3.typeListSize] = $1.type;
										$$.idList = (char**) realloc($3.idList, sizeof(char*)*($3.typeListSize + 1));
										$$.idList[$3.typeListSize] = $1.idName;
										//cout<<"formalslist -> formaldecl COMMA formalslist"<<endl;
									}

formaldecl : type ID 			{
									$$.type = $1.type;
									$$.idName = $2.idName;
									//cout<<"formaldecl -> type ID "<<endl;
								}

rettype 
	: type 						{
								$$.type=$1.type;
								//cout<<"rettype -> type  "<<endl;
								}
	| VOID 						{
								$$.type=VOID_T;
								//cout<<"rettype -> VOID"<<endl;
								}
%%

int main()
{
	yyparse();
}

void yyerror(char* message)
{
	errorSyn(yylineno);
	exit(0);
}